---
title: 编程进阶
icon: lightbulb
dir:
  link: true
---

## 基础算法

### 时间复杂度

#### 为什么需要计算时间复杂度
我们需要预估程序的大概运行时间，当数据量很大的时候，初学者很容易写出1年都运行不完的代码。

#### 如何计算（此处省略诸多细节）
简单来说主要看循环或者递归

时间复杂度O(1)
``` c
int x, y;
scanf("%d%d", &x， &y);
int z = x + y;
if(z == 0)
    printf("123\n");
```

时间复杂度O(n)
``` c
int ans = 0;
for(int i = 1; i <= n; i++) {
    ans += i;
}
```

时间复杂度O(n^2)
``` c
int ans = 0;

for(int i = 1; i <= n; i++) {
    ans += i;
}

for(int i = 1; i <= n; i++) {
  for(int j = 1; j <= n; j++) {
    ans += i;
  }
}
```

更多内容可以参考[OI WiKi](https://oi.wiki/basic/complexity/)

#### 常数优化
除了时间复杂度，我们还要进行更细致的优化，比如`a*512`可以改成`a << 9`,后者会更快。

### 二分算法
[先看别人的](https://www.hello-algo.com/chapter_searching/binary_search/)


## 数据结构简介
### 链表
链表是一种用于存储数据的数据结构，通过如链条一般的指针来连接元素。它的特点是插入与删除数据十分方便，但寻找与读取数据的表现欠佳。

![img](/5208482922.jpg)
如果想在数组中插入一个数，需要把后面的数都右移一位，时间复杂度`O(n)`
但链表中的元素只需要更改一下next指针，时间复杂度`O(1)`

### 栈
栈的修改与访问是按照后进先出的原则进行的，入栈会把一个数据放进栈，出栈会把最后入栈的数据取出来

程序运行时也有栈空间，比如函数a中调用了函数b,函数b中调用了函数c,我们只能先从函数c中返回，才能继续执行函数b
如果超出栈大小，就会栈溢出

### 队列
队列是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。

#### 循环队列
使用数组模拟队列会导致一个问题：随着时间的推移，整个队列会向数组的尾部移动，一旦到达数组的最末端，即使数组的前端还有空闲位置，再进行入队操作也会导致溢出（这种数组里实际有空闲位置而发生了上溢的现象被称为「假溢出」）。

解决假溢出的办法是采用循环的方式来组织存放队列元素的数组，即将数组下标为 0 的位置看做是最后一个位置的后继。（数组下标为 x 的元素，它的后继为 (x + 1) % SIZE）。这样就形成了循环队列。

循环队列常用于充当软/硬件的缓冲区，比如数字ic面试时，面试官经常要求应聘者当场手写fifo。

### 二叉树
![img](/3282078754.jpg)

### 堆
堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。

每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。

## 部分语言特性介绍

### 类与对象
### 继承
### 多态
### 封装
### 模板
### 重载
### 命名空间